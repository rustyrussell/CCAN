#include "config.h"
#include <stdio.h>
#include <string.h>

/**
 * filecnt - durable counters using sparse files
 *
 * The filecnt module keeps count by incrementing the size of a file.
 * These counters are easy to read using lseek(2), stat(2), or ls(1).
 * To keep the files small, they are replaced with sparse files at multiples of 4 KiB.
 *
 * The range of the counter is that of off_t.  Compile with _FILE_OFFSET_BITS set to 64
 * to count beyond 2 GiB.
 *
 * Tests suggest this approach performs on par with writing a raw uint every time and
 * is 4 to 5 times faster than using ftruncate only.
 *
 * Example:
 *	#include <err.h>
 *	#include <stdio.h>
 *	#include <ccan/filecnt/filecnt.h>
 *
 *	int main(int argc, char *argv[])
 *	{
 *		FILE *f;
 *		filecnt *h;
 *		off_t n, i;
 *		char buf[BUFSIZ];
 *		int ret;
 *
 *		if (argc != 2) return 1;
 *		f = fopen(argv[1], "r");
 *		if (!f) err(1, "fopen");
 *
 *		h = filecnt_new();
 *		if (!h) err(1, "filecnt_new");
 *
 *		n = filecnt_open(h, "counter");
 *		if (n == -1) err(1, "filecnt_open");
 *
 *		for (i = 0; i < n && !feof(f); i++) {
 *			// skip lines output last run
 *			fgets(buf, sizeof(buf), f);
 *			if (ferror(f)) err(1, "fgets");
 *		}
 *
 *		for (;;) {
 *			fgets(buf, sizeof(buf), f);
 *			if (ferror(f)) err(1, "fgets");
 *			if (feof(f)) break;
 *
 *			fputs(buf, stdout);
 *
 *			ret = filecnt_inc(h);
 *			if (ret == -1) err(1, "filecnt_inc");
 *		}
 *
 *		filecnt_free(h);
 *		return 0;
 *	}
 *
 * License: APACHEv2
 * Author: Dan Good <dan@dancancode.com>
 */
int main(int argc, char *argv[])
{
	/* Expect exactly one argument */
	if (argc != 2)
		return 1;

	if (strcmp(argv[1], "depends") == 0) {
		/* none */
		return 0;
	}

	return 1;
}
